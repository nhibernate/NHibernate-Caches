//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using NHibernate.Cache;
using NHibernate.Caches.StackExchangeRedis.Messages;
using StackExchange.Redis;
using static NHibernate.Caches.StackExchangeRedis.ConfigurationHelper;

namespace NHibernate.Caches.StackExchangeRedis
{
	public partial class DistributedLocalCacheRegionStrategy : AbstractRegionStrategy
	{

		/// <inheritdoc />
		protected override Task ExecutePutAsync(string cacheKey, object value, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			return TryPutLocalAsync(cacheKey, value, DateTime.UtcNow.Ticks, _clientId, true, cancellationToken);
		}

		/// <inheritdoc />
		public override Task<object> GetAsync(object key, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				return Task.FromResult<object>(Get(key));
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		/// <inheritdoc />
		protected override Task<bool> ExecuteRemoveAsync(string cacheKey, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			return TryRemoveLocalAsync(cacheKey, DateTime.UtcNow.Ticks, _clientId, true, cancellationToken);
		}

		/// <inheritdoc />
		public override Task ClearAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			try
			{
				Log.Debug("Clearing region: '{0}'.", RegionKey);
				return TryClearLocalAsync(DateTime.UtcNow.Ticks, _clientId, true, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<object>(ex);
			}
		}

		/// <inheritdoc />
		public override Task<string> LockAsync(object key, CancellationToken cancellationToken)
		{
			if (key == null)
			{
				throw new ArgumentNullException(nameof(key));
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<string>(cancellationToken);
			}
			return InternalLockAsync();
			async Task<string> InternalLockAsync()
			{

				var lockKey = GetLockKey(key);
				Log.Debug("Locking key: '{0}'.", lockKey);
				var lockValue = _lockValueProvider.GetValue();
				using (var cacheLockValue = new CacheLockValue(lockValue))
				{
					object Context() => new KeyValuePair<string, CacheLockValue>(lockKey, cacheLockValue);
					return await (_retryPolicy
						.ExecuteAsync(async () =>
						{
							if (!LockLocal(lockKey, cacheLockValue))
							{
								Log.Debug("Failed to acquire lock for key '{0}' in the local cache, retrying...", lockKey);
								return null; // Retry
							}

							cacheLockValue.Setup();
							var subscriberCount = await (_subscriber.PublishAsync(_synchronizationChannel, Serializer.Serialize(new CacheSynchronizationMessage
							{
								OperationType = OperationType.Lock,
								Timestamp = DateTime.UtcNow.Ticks,
								ClientId = _clientId,
								Data = new LockData
								{
									LockKey = lockKey,
									LockValue = lockValue
								}
							}))).ConfigureAwait(false) - 1;

							if (subscriberCount == 0)
							{
								Log.Debug("Acquired lock for key '{0}', no other caches were involved.", lockKey);
								// We are the only one subscribed
								return cacheLockValue.Value;
							}

							Log.Debug("Waiting lock result from '{0}' other local caches.", subscriberCount);
							IncreaseLock(cacheLockValue, subscriberCount);
							if (!await (cacheLockValue.Semaphore.WaitAsync(_lockAcquireTimeout, cancellationToken)).ConfigureAwait(false) || cacheLockValue.Failed)
							{
								Log.Debug("Failed to acquire lock for key '{0}' from '{1}' other local caches, retrying...", lockKey, subscriberCount);
								return null;
							}

							Log.Debug("Acquired lock for key '{0}', '{1}' other caches were involved.", lockKey, subscriberCount);
							return cacheLockValue.Value;
						}, Context, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		/// <inheritdoc />
		public override Task<string> LockManyAsync(object[] keys, CancellationToken cancellationToken)
		{
			if (keys == null)
			{
				throw new ArgumentNullException(nameof(keys));
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<string>(cancellationToken);
			}
			return InternalLockManyAsync();
			async Task<string> InternalLockManyAsync()
			{

				var lockKeys = new string[keys.Length];
				var lockValue = _lockValueProvider.GetValue();
				for (var i = 0; i < keys.Length; i++)
				{
					lockKeys[i] = GetLockKey(keys[i]);
					Log.Debug("Locking key: '{0}'.", lockKeys[i]);
				}

				using (var cacheLockValue = new CacheLockValue(lockValue))
				{
					object Context() => new KeyValuePair<string[], CacheLockValue>(lockKeys, cacheLockValue);
					return await (_retryPolicy
						.ExecuteAsync(async () =>
						{
							if (!LockManyLocal(lockKeys, cacheLockValue))
							{
								Log.Debug("Failed to acquire lock for '{0}' keys in the local cache, retrying...", lockKeys.Length);
								return null; // Retry
							}

							cacheLockValue.Setup();
							var subscriberCount = await (_subscriber.PublishAsync(_synchronizationChannel, Serializer.Serialize(new CacheSynchronizationMessage
							{
								OperationType = OperationType.LockMany,
								Timestamp = DateTime.UtcNow.Ticks,
								ClientId = _clientId,
								Data = new LockManyData
								{
									LockKeys = lockKeys,
									LockValue = lockValue
								}
							}))).ConfigureAwait(false) - 1;

							if (subscriberCount == 0)
							{
								Log.Debug("Acquired lock for '{0}' keys, no other caches were involved.", lockKeys.Length);
								// We are the only one subscribed
								return cacheLockValue.Value;
							}

							Log.Debug("Waiting lock result from '{0}' other local caches.", subscriberCount);
							IncreaseLock(cacheLockValue, subscriberCount);
							if (!await (cacheLockValue.Semaphore.WaitAsync(_lockAcquireTimeout, cancellationToken)).ConfigureAwait(false) || cacheLockValue.Failed)
							{
								Log.Debug("Failed to acquire lock for '{0}' keys from '{1}' other local caches, retrying...", lockKeys.Length, subscriberCount);
								return null;
							}

							Log.Debug("Acquired lock for '{0}' keys, '{1}' other caches were involved.", lockKeys.Length, subscriberCount);
							return cacheLockValue.Value;
						}, Context, cancellationToken)).ConfigureAwait(false);
				}
			}
		}

		/// <inheritdoc />
		public override Task<bool> UnlockAsync(object key, string lockValue, CancellationToken cancellationToken)
		{
			if (key == null)
			{
				throw new ArgumentNullException(nameof(key));
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			try
			{

				var lockKey = GetLockKey(key);
				Log.Debug("Unlocking key: '{0}'.", lockKey);

				return UnlockKeyAsync(lockKey, lockValue, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<bool>(ex);
			}
		}

		/// <inheritdoc />
		public override Task<int> UnlockManyAsync(object[] keys, string lockValue, CancellationToken cancellationToken)
		{
			if (keys == null)
			{
				throw new ArgumentNullException(nameof(keys));
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<int>(cancellationToken);
			}
			try
			{

				var lockKeys = new string[keys.Length];
				for (var i = 0; i < keys.Length; i++)
				{
					lockKeys[i] = GetLockKey(keys[i]);
					Log.Debug("Unlocking key: '{0}'.", lockKeys[i]);
				}

				return UnlockManyKeysAsync(lockKeys, lockValue, cancellationToken);
			}
			catch (Exception ex)
			{
				return Task.FromException<int>(ex);
			}
		}

		private async Task<bool> UnlockKeyAsync(string lockKey, string lockValue, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			await (PublishAsync(Serializer.Serialize(new CacheSynchronizationMessage
			{
				OperationType = OperationType.Unlock,
				ClientId = _clientId,
				Timestamp = DateTime.UtcNow.Ticks,
				Data = new LockData
				{
					LockKey = lockKey,
					LockValue = lockValue
				}
			}))).ConfigureAwait(false);

			return UnlockLocal(lockKey, lockValue);
		}

		private async Task<int> UnlockManyKeysAsync(string[] lockKeys, string lockValue, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			await (PublishAsync(Serializer.Serialize(new CacheSynchronizationMessage
			{
				OperationType = OperationType.UnlockMany,
				ClientId = _clientId,
				Timestamp = DateTime.UtcNow.Ticks,
				Data = new LockManyData
				{
					LockKeys = lockKeys,
					LockValue = lockValue
				}
			}))).ConfigureAwait(false);

			return UnlockManyLocal(lockKeys, lockValue);
		}

		private Task<bool> TryRemoveLocalAsync(string cacheKey, long timestamp, int clientId, bool publish, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			return ExecuteOperationAsync(cacheKey, null, timestamp, clientId, publish, true, cancellationToken);
		}

		private Task<bool> TryPutLocalAsync(string cacheKey, object value, long timestamp, int clientId, bool publish, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<bool>(cancellationToken);
			}
			return ExecuteOperationAsync(cacheKey, value, timestamp, clientId, publish, false, cancellationToken);
		}

		private async Task<bool> ExecuteOperationAsync(string cacheKey, object value, long timestamp, int clientId, bool publish, bool remove, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var message = publish
				? Serializer.Serialize(new CacheSynchronizationMessage
				{
					OperationType = remove ? OperationType.Remove : OperationType.Put,
					ClientId = _clientId,
					Timestamp = timestamp,
					Data = remove
						? (object) cacheKey
						: new PutData
						{
							Key = cacheKey,
							Value = value
						}
				})
				: null;
			var cacheValue = (CacheValue) _memoryCache.Get(cacheKey);
			cancellationToken.ThrowIfCancellationRequested();
			if (cacheValue == null && await (TryPutLocalAsync()).ConfigureAwait(false))
			{
				return !remove;
			}

			var lockValue = cacheValue.Lock;
			await (lockValue.WaitAsync(cancellationToken)).ConfigureAwait(false);
			try
			{
				if (!IsActionValid(timestamp, clientId))
				{
					return false;
				}

				cacheValue = (CacheValue) _memoryCache.Get(cacheKey);
				cancellationToken.ThrowIfCancellationRequested();

				// When a different thread calls TryPutLocal at the begining of the method
				// and gets the lock before the current thread we have to retry to put as the lock
				// value is not valid anymore
				if (cacheValue == null && await (TryPutLocalAsync()).ConfigureAwait(false)) // The key expired in the meantime
				{
					return !remove;
				}

				if (lockValue != cacheValue.Lock)
				{
					return await (ExecuteOperationAsync(cacheKey, value, timestamp, clientId, publish, remove, cancellationToken)).ConfigureAwait(false);
				}

				if (cacheValue.Timestamp == timestamp)
				{
					if (Log.IsDebugEnabled())
					{
						Log.Debug(
							"The timestamp for the key '{0}' is equal to the current one... " +
							"comparing the client id in order to determine who has a higher priority. ", cacheKey);
					}

					if (cacheValue.ClientId > clientId)
					{
						return false;
					}
				}
				else if (cacheValue.Timestamp > timestamp)
				{
					return false;
				}

				if (cacheValue is RemovedCacheValue)
				{
					if (remove)
					{
						cacheValue.Timestamp = timestamp;
						cacheValue.ClientId = clientId;
						cacheValue.Version = _version;
					}
					else
					{
						cacheValue = new CacheValue(value, timestamp, clientId, _version, cacheValue.Lock);
					}
				}
				else
				{
					if (remove)
					{
						cacheValue = new RemovedCacheValue(timestamp, clientId, _version, cacheValue.Lock);
					}
					else
					{
						cacheValue.Value = value;
						cacheValue.Timestamp = timestamp;
						cacheValue.ClientId = clientId;
						cacheValue.Version = _version;
					}
				}

				if (remove)
				{
					_memoryCache.Put(cacheKey, cacheValue, _maxSynchronizationTime);
				}
				else
				{
					_memoryCache.Put(cacheKey, cacheValue);
				}
				
				if (publish)
				{
					cancellationToken.ThrowIfCancellationRequested();
					await (PublishAsync(message)).ConfigureAwait(false);
				}

				return true;
			}
			finally
			{
				lockValue.Release();
			}

			async Task<bool> TryPutLocalAsync()
			{
				await (_writeLock.WaitAsync(cancellationToken)).ConfigureAwait(false);
				try
				{
					cacheValue = (CacheValue) _memoryCache.Get(cacheKey);
					if (cacheValue != null)
					{
						return false;
					}

					if (remove)
					{
						_memoryCache.Put(cacheKey, new RemovedCacheValue(timestamp, clientId, _version), _maxSynchronizationTime);
					}
					else
					{
						_memoryCache.Put(cacheKey, new CacheValue(value, timestamp, clientId, _version));
					}

					if (publish)
					{
						await (PublishAsync(message)).ConfigureAwait(false);
					}

					return true;
				}
				finally
				{
					_writeLock.Release();
				}
			}
		}

		private async Task<bool> TryClearLocalAsync(long timestamp, int clientId, bool publish, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var message = publish
				? Serializer.Serialize(new CacheSynchronizationMessage
				{
					OperationType = OperationType.Clear,
					ClientId = _clientId,
					Timestamp = timestamp
				})
				: null;

			await (_writeLock.WaitAsync(cancellationToken)).ConfigureAwait(false);
			try
			{
				if (!IsActionValid(timestamp, clientId))
				{
					return false;
				}

				_lastClearTimestamp = timestamp;
				_lastClearClientId = clientId;
				_version++;
				// Unfortunately we cannot clear the local cache as it can lead to an inconsistent
				// state across local caches due to delays of synchronization messages.

				if (publish)
				{
					cancellationToken.ThrowIfCancellationRequested();
					await (PublishAsync(message)).ConfigureAwait(false);
				}

				return true;
			}
			finally
			{
				_writeLock.Release();
			}
		}
	}
}
